#### 原则

1. 类设计原则：单一职责，场景明确；无状态的？
2. Convert转化语义的定义， Extract Method 重构方式， 同一个方法中，做一组相同层次的语义操作，Converter接口定义了转化的规则，一个对象能够怎么转换，通过其持有的converter决定
3. 各个数据如何组合
4. po对应表结构，一个po对应一个或者多个表，通过继承关系，将大对象形式上拆小
5. 连锁数据结构通过：IGroupBase，IOrgDiff定义
6. 如果抽象领域对象的时候卡壳了，那么就需要考虑是否是业务设计或者理解有问题了；需要考虑重新进行业务建模
7. 实体：具有单独的生命周期，唯一标识，具有一致性，聚合根是否能聚合该实体？该实体的创建销毁是否由聚合根决定？那么这个实体是否就是该聚合根的一部分？
8. 边界内的内容具有一致性：**在一个事务中只修改一个聚合实例**（这里所说的一个事务，可以理解为聚合根的一个方法）。如果你发现边界内很难接受强一致，不管是出于**性能或产品需求**的考虑，应该考虑剥离出独立的聚合，采用最终一致的方式。
9. entity最基本的职责就是确保连续性？与id有关的属性保留在entity中；
10. 实体往往通过协调其关联对象的操作来完成自己的职责
11. 识别具有生命周期的对象（需要关注其连续性）或者具有唯一性的对象（这样的识别在业务中是有价值的，理论上来说，基本上所有的对象都具有这两种特性，但是对业务是否有价值呢？我们是否关心具体使用的是哪个对象？），这样的对象就是实体
12. valobj所包含的属性应该形成一个整体的概念，我们只关心这种模型的属性；（一个房间中的所有插座问题？）
13. 为什么valobj需要设计为不可变的：共享与复制
14. 固定规则（数据变化时必须保持的一致性规则）？对象间的联系与冲突？
15. 聚合根：数据修改的单元，边界与根？边界定义了聚合根内部都有什么（边界内的内容具有强一致性），根则是聚合根所包含的一个特殊entity（根实体），外部对象除了根实体，看不到其他的任何对象
16. 不能饶过聚合根来修改其内部的对象，确保固定规则
17. 在一个事务中只修改一个聚合实例；如果多个对象是关联修改的（在所有的业务逻辑中，对象都是关联修改的，他们之间具有一致性），那么将他们聚合吧。trade & tradeItem 是关联修改的吗？如果分开进行修改，是否能满足强一致性？删除修改tradeItem都必须判断trade状态 -> 21?
18. 如果你发现边界内很难接受强一致，不管是出于性能或产品需求的考虑，应该考虑剥离出独立的聚合，采用最终一致的方式。（采购单业务？商品的价格修改，是否会影响到采购单，将商品与采购单拆开，使用最终一致性；订单与药品） — 具有强一致性的对象应该由聚合根统一管理
19. 抽象各种对象 -》识别其中的实体以及值对像 -》识别各个对象之间的关系 -》聚合各个对象得到聚合根（通常一个实体就可以得到一个聚合根） -》检查是否满足业务规则，修改聚合（是否是强一致性还是最终一致性 ）
20. 找出强一致性的规则（建模真正的不变条件）
21. 订单是否应该聚合tradeItem（删除的时候，修改item的价格时，trade收费并发）？charge？stock & stockItem & yp_msg；如何避免大聚合的产生（考虑一个订单产生 -》收费 -》发药 流程）？（考虑charge&stock的唯一性判断标识，一个trade对应唯一的charge与stock，charge可以多次进行，可以考虑抽个顶层的charge，流水记录为item，但是如果要根据一个itemId去修改一个item，如何修改？那就将Item作为一个聚合根吧，哪如何避免重费收费的情况？），理论上来说，trade可以把一切因其而存在的事物包含进来（**我们应该关注的聚合的一致性边界，而不是创建一个对象树**）；考虑是否存在直接的全局访问，如果没有，就没有必要抽成一个聚合根，即是否有独立的场景去修改或者创建（**什么时候应该去将一个聚合拆成一个小聚合？**1. 最终一致性可以满足业务规则，2. 独立的访问场景出现时？(这种情况是否可以采用特殊的处理方式避免？)，3. 性能影响可以忽略）；
22. **对象间的关系**：合作（上下游 || 紧密合作，很强的依赖）（trade & charge || stock），从属（ tradeItem依赖trade而存在，tradeItem的所有操作，都得去考虑trade的状态），主从关系、依赖关系
23. **聚合根与聚合根之间的通信**
24. 业务规则：增删改
25. 可以通过优化业务模型的方式减少对象间的依赖，采用最终一致性；能更好的反映业务实际情况
26. 具有高竞争性的对象，需要优化业务模型减少对其的依赖，难以保证强一致性 -> 17
27. 任务更好拆分，一个开发人员可以全身心的投入到相关的一个单独的上下文中；
28. 沟通更加顺畅，一个上下文可以明确自己对其他上下文的依赖关系，从而使得团队内开发直接更好的对接。
29. 提问者与回答者（应用层与领域层）
30. 对象间存在明确的关联关系
31. ref：21；charge抽象成charge + item的形式，会通过订单去进行访问（通过唯一标识：tradeId），还会直接通过itemId去访问（比如微信收费成功后的通知，为了保证可重入性，需要提供关闭操作），如何处理？判断规则，1. 总金额不得超过订单总金额；2. 收费成功后trade需要修改状态（**最终一致性保证，幂等性**）；**3. 一个订单可以收费多次，一次只能进行单次收费，重复收费是不允许存在的(因为这个规则的存在，导致设计变得复杂)；**4. 如果是欠费的话，欠费总金额不得超过订单总金额；**5. 同一时刻，只能有一次收费进行，还要可重入；**6. 欠费再收费是针对已欠费的单子进行的；7. 退费可以分成多次退，同样同一时刻只能有一次退费进行（serail 与 charge两个聚合根，serail维护一个正在处理中的chargeId，）8. 收费完成后会产生流水记录 -> 创建一个chargeHandle，收费成功后，才创建一个chargeLog
32. 围绕**数据库的驱动设计**，新项目总是从设计数据库及其字段开始。导致过程化设计编程，丧失了面向对象设计的优点。
33. 解耦的意义是在于让你这个组干得活不受别人组的影响，你干的活不会受别人影响，今天干的活不受昨天的影响，今天下午干的活不受上午的影响。
34. 结合DDD的理论支持，使得微服务架构能够落地，将一个单体应用很好的拆分成各个微服务，能够快速迭代，快速发布满足业务需求。
35. 团队成员写出来的代码风格比较统一 每个人知道代码往哪个地方写，新人来了，能够很快上手。
36. jpa直接管理聚合根优劣？
37. 那么如何实现聚合根与聚合根之间的通信呢？方法有两个：1）如果是经典的DDD设计，那么应该让领域服务来完成多个聚合根之间的通信，领域服务知道该如何以**面向过程**的方式如何先调用第一个聚合根做事情，然后再调用第二个聚合根做事情，以此类推。这种方法实际上是一个面向过程的思维，对象实际上已经沦落为被操纵的数据了；2）因为聚合根内不允许注入仓储、服务，并且也不能直接引用其他聚合根，那么如果交互呢？可以通过领域事件实现，即在聚合中如果做了什么操作，本来该调用其他聚合根做事情的地方触发一个领域事件出来，然后其他的领域对象监听该事件，从而完成对象之间的通信。但是如何获取监听者呢（即聚合根）？
38. **单个事务修改单个聚合根(unit of work)**，除非有很充足的理由破坏这一原则
39. 明确业务功能，明确业务规则，根据业务功能与规则，设计业务模型，识别业务模型中的domain类型，进行聚合
40. 大聚合拆分的方案：1. 最终一致性；2. 试图保持多个聚合之间的一致性通常说明我们缺少了一些聚合不变的条件，为了满足新的业务规则，我们会创建一个新的聚合
41. 业务用例很重要
42. 在调用聚合行为方法之前，使用资源库或者领域服务获取所需要的对象；而如果要处理特定于领域的复杂依赖关系，在聚合的命令方法中使用领域服务却是最好的方法（失联领域模型）？
43. The Domain should be completely unaware of data persistence, and should assume that it happens automagically.entities should not be concerned with performing actions on the db.
44. 聚合表达了与事务一致性边界相同的意思
45. 业务决定聚合，业务改变聚合。聚合设计的小除了可以降低并发冲突的可能性之外，同样减少了业务改变的时候，聚合的拆分个数，降低了聚合大幅重构（拆分）的可能性，从而能让我们的领域模型更能适应业务的变化。
46. 识别聚合是认知潜在核心业务规则的过程，而定义出来的聚合是在大家共识基础上对核心业务规则的封装。
47. 需要设计，意味着，需要较宽的业务知识积累，较高的抽象设计，能覆盖昨天，今天，明天的需求；较长的思考时间；较长的实施；较多的工作量；较大的风险。这一般**和大多数需求开发周期短，系统稳定性高是矛盾的**。**业务的重要性高于设计，还是设计的重要性高于业务？到底谁服务谁？**
48. 不要过于纠结于DDD中的名字，战术，具体技术（这里具体技术指entity value obj，aggregate，service，repository，event sourcing，CQRS）了解DDD的目的和要解决的问题，才是最重要的，了解为什么要domain driven才是最重要的。
49. DDD是很多best practise，理论与实践 综合在一起整理而成的一套系统理论，用来方便沟通与讨论，其中特别强调了从业务出发，domain dictate tech implementation。
50. **不建议DDD开发，只建议DDD重构。**
51. 告诉而非询问原则
52. **一个业务用例对应一个事务，一个事务对应一个聚合根，也即在一次事务中，只能对一个聚合根进行操作。**
53. 就拿package来说，它不仅仅是一个放一堆类的地方，更是一种表达机制
54. 业务逻辑放入领域模型，而与外部世界的交互 - 应该放入应用服务。
55. **一个entity只能被一个聚合根引用？？**
56. 如何避免聚合中只有与创建保存相关的业务逻辑？
57. 聚合应该聚合哪些业务逻辑？大聚合还是小聚合？聚合根与其聚合的实体通常是1:N的关系，如果N=0的时候，聚合根是否还有存在的意义（业务一致性规则，或者说实体状态变动与聚合的状态变动是否是强一致性的）？如果非强一致性，那么N就可以拆出来做成另一个聚合
58. 聚合根与数据表并不一定是一一对应的，建模与数据表没有任何关系
59. **如果你在构建一个简单的CRUD系统，除了对象创建、获取，更新和删除，没什么别的复杂逻辑，那就忘了DDD。那样会让你的生活清爽许多。**
