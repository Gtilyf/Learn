NIO（非阻塞IO）是一种IO编程模型，Golang中的IO底层实现方式和java NIO模型一致，通俗点说就是都采用了EPOLL。 你在使用golang读文件的时候，goroutine 会默默的挂起，只是你不知道，当读完毕了，goroutine 再次恢复，但你不用担心，goroutine 的挂起和恢复没有java线程那样可怕，你可以认为goroutine 的挂起和恢复就是保存和恢复几个变量的值，其实也是这样的。

剩下的就是goroutine 和 java线程的区别了，goroutine是用户态的线程切换，java采用的是系统线程切换，用汇编语言描述是一个(java)调用int 80软中断,一个没有。 意味着goroutine更轻量级，可以同时相应成千上万的线程切换，java你创造上千个线程就有些吃力了。

因为java线程不能创造过多的线程，如果同时处理上万上千的请求时候，就要考虑在几十个线程来处理上万上千的请求，这就出现了很多请求和线程不可能一一对应，所以通常做法是每个线程分别处理单个请求各个阶段。好比流水线，请求是要加工的商品，每个线程处理一道工序，这样做的好处是每人都做自己熟悉的，对于程序来说每个线程执行的代码永远都是自己很短的一块，这样根据局部优化原理，更具备CPU，内存亲和力，利于JIT。说这样多，就是说如果线程和请求不能一一对应，流水线式的并发编程很麻烦，阅读性也很差，通常是线程A里面一段逻辑代码，线程B又有另一处处理的逻辑代码。

由于goroutine 的轻便，你可以将请求和goroutine 一一对应起来，不用考虑将请求在线程之间换来换去，只关心你的业务逻辑，这就是goroutine 的好处。

**总结：**

golang的goroutine让你比java更容易编写并发程序，但性能不会有差别（目前来说，golang性能还不能和java比，看过代码就知道了，GC弱到爆），代码不会减少，该写的逻辑还得写。ps，其实golang的(sched)go程切换代码虽然原理和java的fork-join框架一样，但是fork-join比golang的sched代码牛逼不少，开始膜拜Doug Lea吧，golang还有很长的路要走。

我们分别来看看java和golang实现并发任务的机制，java里面是Thread，golang里面是goroutine。比如你想创建一个发邮件任务，一个接受消息任务，对应的就是java创建2个独立线程，golang创建2个独立的goroutine。

java和golang的程序最终都是在操作系统上执行的，以linux操作系统为例，操作系统有自己的多线程机制，调用 [clone(2) - Linux manual page**](https://link.zhihu.com/?target=http%3A//man7.org/linux/man-pages/man2/clone.2.html) clone函数就可以创建一个线程。

java线程和操作系统是一对一的关系，也就是说当你创建一个java线程的时候，实际上系统同时创建了一个系统线程来跑该java线程，同理java的所以的线程操作都是和系统线程有对应的实现，比如sleep啥的。

随着高并发时代的到来，通常一个系统通常会有成千上万个任务要同时执行，理论上要创建成千上万个线程分别来执行每个任务，但通常你的电脑只有几个cpu，如果这样，就会有上万个线程来分享这几个cpu，这就涉及到切换线程来占用cpu，每次切换动作，需要保存上一个线程的context（上下文）然后把下一个线程的上下文提出出来给cpu。这样会有啥问题呢？上面说道java的线程是系统原生的线程，所以java线程的切换都是系统级别的线程切换，这样每次切换除了要保存和提取，重要的是进程要从用户态切换系统态下来完成，总之啦，就是每次线程切换都很耗费资源啦。

如果真的有很多线程同时跑在系统上，很多资源都耗费在现场切换上了，java通常上了2k个线程就受不了啦，不知道现在咋样了。所以啊，java这种线程和系统线程一一对应的关系就有些问题啦。

不过知道了问题的所在是操作系统的线程耗费资源，就应该让用户的任务和系统线程不要一一对应了吧。于是就有了threadpool，一个线程池少数几个线程对应多个任务，但是这样任务的状态啥的要你自己维护了，so，写这样的代码就需要功力啦，所以呀现在会并发编程的码农可值钱啦。

那有人就说，如果一种机制可以让语言的线程和系统的线程多对一，这样可以一个任务对应一个语言线程，而很少几个系统线程来处理这几个语言线程，该多好啊。哈哈，大牛们早就想到啦，所以提出了协程(routine)的概念（也叫超线程，就是线程上的线程），采用的切换算法就是work-steel算法。

说道这里，你应该明白了吧，goroutine就是我们说的协程（routine），他能让你采用很简单的编程模型编写能处理高并发的程序，这就是goroutine的好处。
